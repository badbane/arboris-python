# coding=utf-8

"""
Generates a matlab file that would create the arboris-matlab equivalent to
an arboris-python robot.
"""
__author__ = ("Joseph SALINI <joseph.salini@gmail.com>",
              "Sébastien BARTHÉLEMY <sebastien.barthelemy@gmail.com>")

from arboris import joints, shapes
from numpy import zeros, eye

class ConversionError(RuntimeError):
    pass

class  MatlabConverter(object):
    """Generates a matlab file that would create the arboris-matlab equivalent to an arboris-python robot.

    **Tests:**
    
    >>> from arboris.core import simplearm
    >>> import cStringIO
    >>> w = simplearm()
    >>> from arboris.robots.human36 import add_human36
    >>> add_human36(w)
    >>> mc = MatlabConverter(w)
    >>> stream = cStringIO.StringIO()
    >>> #stream = open(filename, "w")
    >>> mc.make_robot(w.ground.childrenjoints[0], stream, 'simplearm')
    Traceback (most recent call last):
        ...
    ConversionError: The root joint must be a FreeJoint.
    >>> mc.make_robot(w.ground.childrenjoints[1], stream, 'human36')
    Traceback (most recent call last):
        ...
    ConversionError: Cannot convert joints of type "<class 'arboris.joints.RzRyRxJoint'>".
    >>> stream.close()

    The tests uses ``cStringIO.StringIO()`` instead of ``open()`` in 
    order to avoid cluttering the filesystem, but the expected usage is 
    to write in files.
    
    """

    def __init__(self, world):
        self.w = world
        self._b_map = {}
    
    def make_robot(self, root_joint, stream, name=None):
        if not isinstance(root_joint, joints.FreeJoint):
            raise ConversionError("The root joint must be a FreeJoint.")
        self.stream = stream
        try:
            self._add_tree(name)
            self._add_branch(1)
            self._traverse( [root_joint], 1, 1 )
            self.add_shapes()
            self.close_stream()
        except:
            self.stream.write(
                "\n!!! SOMETHING WENT MAD: do not use this file !!!\n")
            raise

    def _add_tree(self, name):
        """Add the headings for a new (empty) tree."""
        
        text = """
% This file was auto-generated by arboris-python

function robot = create_{name}()
%Returns a robot, named {name}.

% create a tree struct that will be later converted
tree.name = '{name}';
""".format(name=name) #TODO: we should ensure name is a valid matlab function name (no -,+...)
        self.stream.write(text) 
    
    def _finish(self):
        text="""
robot = arb_robot(arb_treestructtree(tree));
"""
        self.stream.write(text)

    
    def _add_branch(self, num_br, parent=(0,0) ):
        """Add the headings for a new (empty) branch."""
    
        text = """
%% Create branch {br}:
tree.br({br}).name = 'branch {br}';
tree.br({br}).root_jk={par};
""".format(br=num_br, par="{"+str(parent[0])+" "+str(parent[1])+"}")
        self.stream.write(text) 
        
    
    def _add_link(self, joint, num_br, num_bd):
        """Add a link (a joint and its child body)."""
        
        H00L1 = joint.frames[0].bpose
        H11L0 = joint.frames[1].bpose
        body = joint.frames[1].body
        self._b_map[body.name] = (num_br, num_bd)
        if isinstance(joint, joints.RxJoint):
            jtype = "[0 0 0 1 0 0]"
        elif isinstance(joint, joints.RyJoint):
            jtype = "[0 0 0 0 1 0]"
        elif isinstance(joint, joints.RzJoint):
            jtype = "[0 0 0 0 0 1]"
        elif isinstance(joint, joints.FreeJoint):
            if num_br != 1 or num_bd != 1:
                raise ConversionError(
                    'FreeJoint is only available as the root joint.')
            jtype = "eye(6)"
        else:
            raise ConversionError(
                'Cannot convert joints of type "{0}".'.format(type(joint)))
        text = """
tree.br({br}).bd({bd}).name = '{name}'; % body name is '{name2}'
tree.br({br}).bd({bd}).E = {jtype}';
tree.br({br}).bd({bd}).H_0_0L1 = ...
{H0};
tree.br({br}).bd({bd}).H_1_1L0 = ...
{H1};
tree.br({br}).bd({bd}).M = ...
{mass};
tree.br({br}).bd({bd}).shape(1).type = 'sphere';
tree.br({br}).bd({bd}).shape(1).dims = [0.01];
tree.br({br}).bd({bd}).shape(1).H = eye(4);
""".format(
        br=num_br,
        bd=num_bd,
        name=joint.name,
        name2=body.name,
        mass=_flip(body.mass),
        jtype=jtype,
        H0 = H00L1,
        H1 = H11L0
        )
        self.stream.write(text)
       
        
    def _add_shapes(self):
        """Add the shapes for all the links."""
        
        self.stream.write("\n\n% Write the registered contacting shapes\n")
        num_in_bd = {}
        s = self.w.getshapesdict()
        for v in s.itervalues():
            body = v.frame.body
            (br,bd)= self._b_map[body.name]
            if body.name in num_in_bd.iterkeys():
                num_in_bd[body.name] += 1
            else:
                num_in_bd[body.name] = 2
            if isinstance(v, shapes.Point):
                stype='sphere'
                dims='[0.01]'
            Hpose=v.frame.bpose
            text="""
tree.br({br}).bd({bd}).shape({num}).type = '{stype}';
tree.br({br}).bd({bd}).shape({num}).dims = {dims};
tree.br({br}).bd({bd}).shape({num}).H = {H};
tree.br({br}).bd({bd}).shape({num}).gr_props = {visu};
""".format(
                br=br,
                bd=bd,
                num=num_in_bd[body.name],
                stype=stype,
                dims=dims,
                H=Hpose,
                visu="{'FaceColor','Visible'; [1 0 0] ,'on'}")
            self.stream.write(text)
        
    
    def _traverse(self, joints, br, bd):
        """Recurse through the tree."""
        parent = (br, bd-1)
        if len(joints) == 0:
            # we are at the end of a branch
            return br
        else:
            j = joints[0]
            self._add_link(j, br, bd)
            bd += 1
            br = self._traverse(j.frames[1].body.childrenjoints, br, bd)
            for j in joints[1:]:
                br+=1
                self._add_branch(br, parent)
                self._add_link(j, br, 1)
                br = self._traverse(j.frames[1].body.childrenjoints, br, 2)
            return br


def _flip(m):
    """Flip anti-diagonal blocks of an array."""
    assert m.shape == (6, 6)
    fm = zeros((6,6))
    fm[0:3,0:3] = m[3:6,3:6]
    fm[3:6,3:6] = m[0:3,0:3]
    fm[0:3,3:6] = m[3:6,0:3]
    fm[3:6,0:3] = m[0:3,3:6]
    return fm

